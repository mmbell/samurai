#include <limits>
#include <cmath>
#include <netcdfcpp.h>

#include "ErrorData.h"
#include <netcdfcpp.h>

// This returns a one dimentional array of error data for the Mish

double  *ErrorData::init(QString fname, const QHash<QString, QString>* config, size_t numVar)
{
  configHash = config;
  varDim = numVar;
  
  // set defaults from the config hash

  bgError[0] = configHash->value("bg_rhou_error").toFloat();
  bgError[1] = configHash->value("bg_rhov_error").toFloat();
  bgError[2] = configHash->value("bg_rhow_error").toFloat();
  bgError[3] = configHash->value("bg_tempk_error").toFloat(); // temp
  bgError[4] = configHash->value("bg_qv_error").toFloat();    // moisture
  bgError[5] = configHash->value("bg_rhoa_error").toFloat();  // 
  bgError[6] = configHash->value("bg_qr_error").toFloat();    // reflectivity

  // Read variance from fractl_nc_file
  
  NcError err(NcError::verbose_nonfatal);
  // const char *fname = configHash->value("fractl_nc_file").toLatin1().data();  
   // Open the file.
  NcFile dataFile(fname.toLatin1().data(), NcFile::ReadOnly);
   
   // Check to see if the file was opened.
   if(!dataFile.is_valid()) {
     std::cout << "Failed to read FRACTL generated nc file " << fname.toLatin1().data()
	       << std::endl;
     return NULL;
   }

   NcDim *z0Dim = dataFile.get_dim("z0");
   if (! z0Dim)
     return NULL;

   NcDim *y0Dim = dataFile.get_dim("y0");
   if (! y0Dim)
     return NULL;

   NcDim *x0Dim = dataFile.get_dim("x0");
   if (! x0Dim)
     return NULL;

   // Set the Mish size
   
   mish_nz = z0Dim->size();
   mish_ny = y0Dim->size();
   mish_nx = x0Dim->size();

   // Set the Mesh size

   NcAtt *dim;
   dim = dataFile.get_att("sam_idim");
   if (dim != NULL)
     mesh_nx = dim->as_long(0);
   
   dim = dataFile.get_att("sam_jdim");
   if (dim != NULL)
     mesh_ny = dim->as_long(0);
   
   dim = dataFile.get_att("sam_kdim");
   if (dim != NULL)
     mesh_nz = dim->as_long(0);

   if (dim == NULL) {
     std::cout << "Error: ErrorData: " << fname.toLatin1().data()
	       << " doesn't contain Samurai size variables." << std::endl
	       << "       Was it generated by Fractl?" << std::endl;
     mesh_nx = mesh_ny = mesh_nz = 0;
   }
   
   // Get the Error variables
   
   NcVar *uStd = dataFile.get_var("U_std");
   if (! uStd)
     return NULL;   
   NcVar *vStd = dataFile.get_var("V_std");
   if (! vStd)
     return NULL;   
   NcVar *wStd = dataFile.get_var("W_std");
   if (! wStd)
     return NULL;

   size_t tableDim = mish_nz * mish_ny * mish_nx;

   double *uData = new double[tableDim];
   double *vData = new double[tableDim];
   double *wData = new double[tableDim];

   bool success = true;

   if ( ! uStd->set_cur(0, 0, 0, 0) ) {
     std::cout << "Failed to read U_std" << std::endl;
     success = false;
   }
   if ( success && ! uStd->get(uData, 1, mish_nz, mish_ny, mish_nx) ){
     std::cout << "Failed to read U_std" << std::endl;
     success = false;
   }    
   if ( success && ! vStd->set_cur(0, 0, 0, 0) ) {
     std::cout << "Failed to read V_std" << std::endl;
     success = false;
   }
   if ( success && ! vStd->get(vData, 1, mish_nz, mish_ny, mish_nx) ){
     std::cout << "Failed to read V_std" << std::endl;
     success = false;
   }    
   if ( success && ! wStd->set_cur(0, 0, 0, 0) ) {
     std::cout << "Failed to read W_std" << std::endl;
     success = false;
   }
   if ( success && ! wStd->get(wData, 1, mish_nz, mish_ny, mish_nx) ){
     std::cout << "Failed to read W_std" << std::endl;
     success = false;
   }

   if ( success) {
     mishData = new double[tableDim * varDim];	// varDim is 7: u, v, w, t', qv', rho', dbz
     if (mishData == NULL) {
       std::cerr << "Failed to allocate error table" << std::endl;
       success = false;
     }
   }

   // Combine individual error arrays into one bgU like array

   if ( success) {
     for(size_t src_index = 0, dest_index = 0;
	 src_index < tableDim;
	 src_index += 1, dest_index += varDim) {
       
	   double u = uData[src_index];
	   double v = vData[src_index];
	   double w = wData[src_index];

	   // Use values from the config file if we get NaN
	   
	   if (std::isnan(u)) u = bgError[0];
	   if (std::isnan(v)) v = bgError[1];
	   if (std::isnan(w)) w = bgError[2];

	   mishData[dest_index + 0] = u;
	   mishData[dest_index + 1] = v;
	   mishData[dest_index + 2] = w;
	   mishData[dest_index + 3] = bgError[3];
	   mishData[dest_index + 4] = bgError[4];
	   mishData[dest_index + 5] = bgError[5];
	   mishData[dest_index + 6] = bgError[6];	// varDim - 1
	 }
   }
   
   delete[] uData;
   delete[] vData;
   delete[] wData;
   
   return mishData;
}

ErrorData::~ErrorData()
{
  if (meshData != NULL)
    delete[] meshData;
  if (mishData != NULL)
    delete[] mishData;
}

double ErrorData::meshValueAt(size_t var, size_t x, size_t y, size_t z)
{
  // return bgError[var]; // TODO debug. 
  
  if (meshData == NULL)
    return bgError[var];
  if (var >= varDim)
    return bgError[var];    
  size_t index = x + mesh_nx * (y + mesh_ny * z);	 // index order assumed to be meshData[z, y, x]
  double val = meshData[index + var];
  if (std::isnan(val) )
    return bgError[var];
  return val;
}

bool ErrorData::writeDebugNc(const QString& netcdfFileName,
			     bool fMish,
			     double *data)
{
  size_t x, y, z;
  
  if (fMish) {
    x = mish_nx;
    y = mish_ny;
    z = mish_nz;
  } else {
    x = mesh_nx;
    y = mesh_ny;
    z = mesh_nz;
  }
  
  std::cout << "-D- Dumping data in " << netcdfFileName.toLatin1().data() << std::endl;
  
  NcError err(NcError::verbose_nonfatal);
  int NC_ERR = 0;

  // Create the file.
  
  NcFile dataFile(netcdfFileName.toLatin1(), NcFile::Replace);

  // Check to see if the file was created.
  
  if(!dataFile.is_valid())
    return NC_ERR;

  // Dimensions
  
  NcDim *timeDim;
  NcDim *xDim, *yDim, *zDim;

  if (!(timeDim = dataFile.add_dim("time")))	// unlimited dimension
    return NC_ERR;

  if ( ! (xDim = dataFile.add_dim("x_dim", x)))
    return NC_ERR;  
  if ( ! (yDim = dataFile.add_dim("y_dim", y)))
    return NC_ERR;  
  if ( ! (zDim = dataFile.add_dim("z_dim", z)))
    return NC_ERR;  

  // Variables
  
  // NcVar *timeVar;
  
  NcVar *v_U, *v_V, *v_W;	// Original from Fractal

#if 0
  if (!(timeVar = dataFile.add_var("time", ncInt, timeDim)))
    return NC_ERR;
#endif
  
  if (!(v_U = dataFile.add_var("U", ncFloat, timeDim,
				  zDim, yDim, xDim)))
    return NC_ERR;
  if (!(v_V = dataFile.add_var("V", ncFloat, timeDim,
				  zDim, yDim, xDim)))
    return NC_ERR;
  if (!(v_W = dataFile.add_var("W", ncFloat, timeDim,
				  zDim, yDim, xDim)))
    return NC_ERR;

  int rec = 0;
  size_t size = x * y * z;
  double *buf = new double[size];
  
  if (buf == NULL)
    return NC_ERR;

  // --- Write U ----
  
  for (size_t src_idx = 0, dest_idx = 0;
       dest_idx < size;
       src_idx += varDim, dest_idx += 1)
    buf[dest_idx] = data[src_idx + 0];
  
  if (! v_U->put_rec(buf, rec))
    return NC_ERR;

  // --- Write V ----
  
  for (size_t src_idx = 0, dest_idx = 0;
       dest_idx < size;
       src_idx += varDim, dest_idx += 1)
    buf[dest_idx] = data[src_idx + 1];

  if (! v_V->put_rec(buf, rec))
    return NC_ERR;
    
  // --- Write W ----
  
  for (size_t src_idx = 0, dest_idx = 0;
       dest_idx < size;
       src_idx += varDim, dest_idx += 1)
    buf[dest_idx] = data[src_idx + 2];

  if (! v_W->put_rec(buf, rec))
    return NC_ERR;
			 
  delete[] buf;

  return true;
}
