/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
/* ** Copyright UCAR                                                         */
/* ** University Corporation for Atmospheric Research (UCAR)                 */
/* ** National Center for Atmospheric Research (NCAR)                        */
/* ** Boulder, Colorado, USA                                                 */
/* ** BSD licence applies - redistribution and use in source and binary      */
/* ** forms, with or without modification, are permitted provided that       */
/* ** the following conditions are met:                                      */
/* ** 1) If the software is modified to produce derivative works,            */
/* ** such modified software should be clearly marked, so as not             */
/* ** to confuse it with the version available from UCAR.                    */
/* ** 2) Redistributions of source code must retain the above copyright      */
/* ** notice, this list of conditions and the following disclaimer.          */
/* ** 3) Redistributions in binary form must reproduce the above copyright   */
/* ** notice, this list of conditions and the following disclaimer in the    */
/* ** documentation and/or other materials provided with the distribution.   */
/* ** 4) Neither the name of UCAR nor the names of its contributors,         */
/* ** if any, may be used to endorse or promote products derived from        */
/* ** this software without specific prior written permission.               */
/* ** DISCLAIMER: THIS SOFTWARE IS PROVIDED 'AS IS' AND WITHOUT ANY EXPRESS  */
/* ** OR IMPLIED WARRANTIES, INCLUDING, WITHOUT LIMITATION, THE IMPLIED      */
/* ** WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.    */
/* *=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=*=* */
////////////////////////////////////////////
// Params.cc
//
// TDRP C++ code file for class 'Params'.
//
// Code for program samurai
//
// This file has been automatically
// generated by TDRP, do not modify.
//
/////////////////////////////////////////////

/**
 *
 * @file Params.cc
 *
 * @class Params
 *
 * This class is automatically generated by the Table
 * Driven Runtime Parameters (TDRP) system
 *
 * @note Source is automatically generated from
 *       paramdef file at compile time, do not modify
 *       since modifications will be overwritten.
 *
 *
 * @author Automatically generated
 *
 */
#include "Params.hh"
#include <cstring>

  ////////////////////////////////////////////
  // Default constructor
  //

  Params::Params()

  {

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // initialize table

    _init();

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Copy constructor
  //

  Params::Params(const Params& source)

  {

    // sync the source object

    source.sync();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // class name

    _className = "Params";

    // copy table

    tdrpCopyTable((TDRPtable *) source._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = false;

  }

  ////////////////////////////////////////////
  // Destructor
  //

  Params::~Params()

  {

    // free up

    freeAll();

  }

  ////////////////////////////////////////////
  // Assignment
  //

  void Params::operator=(const Params& other)

  {

    // sync the other object

    other.sync();

    // free up any existing memory

    freeAll();

    // zero out table

    memset(_table, 0, sizeof(_table));

    // zero out members

    memset(&_start_, 0, &_end_ - &_start_);

    // copy table

    tdrpCopyTable((TDRPtable *) other._table, _table);

    // set members

    tdrpTable2User(_table, &_start_);

    _exitDeferred = other._exitDeferred;

  }

  ////////////////////////////////////////////
  // loadFromArgs()
  //
  // Loads up TDRP using the command line args.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   char **params_path_p:
  //     If this is non-NULL, it is set to point to the path
  //     of the params file used.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromArgs(int argc, char **argv,
                           char **override_list,
                           char **params_path_p,
                           bool defer_exit)
  {
    int exit_deferred;
    if (_tdrpLoadFromArgs(argc, argv,
                          _table, &_start_,
                          override_list, params_path_p,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadApplyArgs()
  //
  // Loads up TDRP using the params path passed in, and applies
  // the command line args for printing and checking.
  //
  // Check usage() for command line actions associated with
  // this function.
  //
  //   const char *param_file_path: the parameter file to be read in
  //
  //   argc, argv: command line args
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   bool defer_exit: normally, if the command args contain a 
  //      print or check request, this function will call exit().
  //      If defer_exit is set, such an exit is deferred and the
  //      private member _exitDeferred is set.
  //      Use exidDeferred() to test this flag.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadApplyArgs(const char *params_path,
                            int argc, char **argv,
                            char **override_list,
                            bool defer_exit)
  {
    int exit_deferred;
    if (tdrpLoadApplyArgs(params_path, argc, argv,
                          _table, &_start_,
                          override_list,
                          _className,
                          defer_exit, &exit_deferred)) {
      return (-1);
    } else {
      if (exit_deferred) {
        _exitDeferred = true;
      }
      return (0);
    }
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  //

  bool Params::isArgValid(const char *arg)
  {
    return (tdrpIsArgValid(arg));
  }

  ////////////////////////////////////////////
  // isArgValid()
  // 
  // Check if a command line arg is a valid TDRP arg.
  // return number of args consumed.
  //

  int Params::isArgValidN(const char *arg)
  {
    return (tdrpIsArgValidN(arg));
  }

  ////////////////////////////////////////////
  // load()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to load
  // up more than one class for a single application. It is a
  // lower-level routine than loadFromArgs, and hence more
  // flexible, but the programmer must do more work.
  //
  //   const char *param_file_path: the parameter file to be read in.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::load(const char *param_file_path,
                   char **override_list,
                   int expand_env, int debug)
  {
    if (tdrpLoad(param_file_path,
                 _table, &_start_,
                 override_list,
                 expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadFromBuf()
  //
  // Loads up TDRP for a given class.
  //
  // This version of load gives the programmer the option to
  // load up more than one module for a single application,
  // using buffers which have been read from a specified source.
  //
  //   const char *param_source_str: a string which describes the
  //     source of the parameter information. It is used for
  //     error reporting only.
  //
  //   char **override_list: A null-terminated list of overrides
  //     to the parameter file.
  //     An override string has exactly the format of an entry
  //     in the parameter file itself.
  //
  //   const char *inbuf: the input buffer
  //
  //   int inlen: length of the input buffer
  //
  //   int start_line_num: the line number in the source which
  //     corresponds to the start of the buffer.
  //
  //   expand_env: flag to control environment variable
  //               expansion during tokenization.
  //               If TRUE, environment expansion is set on.
  //               If FALSE, environment expansion is set off.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadFromBuf(const char *param_source_str,
                          char **override_list,
                          const char *inbuf, int inlen,
                          int start_line_num,
                          int expand_env, int debug)
  {
    if (tdrpLoadFromBuf(param_source_str,
                        _table, &_start_,
                        override_list,
                        inbuf, inlen, start_line_num,
                        expand_env, debug)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // loadDefaults()
  //
  // Loads up default params for a given class.
  //
  // See load() for more detailed info.
  //
  //  Returns 0 on success, -1 on failure.
  //

  int Params::loadDefaults(int expand_env)
  {
    if (tdrpLoad(NULL,
                 _table, &_start_,
                 NULL, expand_env, FALSE)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // sync()
  //
  // Syncs the user struct data back into the parameter table,
  // in preparation for printing.
  //
  // This function alters the table in a consistent manner.
  // Therefore it can be regarded as const.
  //

  void Params::sync(void) const
  {
    tdrpUser2Table(_table, (char *) &_start_);
  }

  ////////////////////////////////////////////
  // print()
  // 
  // Print params file
  //
  // The modes supported are:
  //
  //   PRINT_SHORT:   main comments only, no help or descriptions
  //                  structs and arrays on a single line
  //   PRINT_NORM:    short + descriptions and help
  //   PRINT_LONG:    norm  + arrays and structs expanded
  //   PRINT_VERBOSE: long  + private params included
  //

  void Params::print(FILE *out, tdrp_print_mode_t mode)
  {
    tdrpPrint(out, _table, _className, mode);
  }

  ////////////////////////////////////////////
  // checkAllSet()
  //
  // Return TRUE if all set, FALSE if not.
  //
  // If out is non-NULL, prints out warning messages for those
  // parameters which are not set.
  //

  int Params::checkAllSet(FILE *out)
  {
    return (tdrpCheckAllSet(out, _table, &_start_));
  }

  //////////////////////////////////////////////////////////////
  // checkIsSet()
  //
  // Return TRUE if parameter is set, FALSE if not.
  //
  //

  int Params::checkIsSet(const char *paramName)
  {
    return (tdrpCheckIsSet(paramName, _table, &_start_));
  }

  ////////////////////////////////////////////
  // freeAll()
  //
  // Frees up all TDRP dynamic memory.
  //

  void Params::freeAll(void)
  {
    tdrpFreeAll(_table, &_start_);
  }

  ////////////////////////////////////////////
  // usage()
  //
  // Prints out usage message for TDRP args as passed
  // in to loadFromArgs().
  //

  void Params::usage(ostream &out)
  {
    out << "TDRP args: [options as below]\n"
        << "   [ -params/--params path ] specify params file path\n"
        << "   [ -check_params/--check_params] check which params are not set\n"
        << "   [ -print_params/--print_params [mode]] print parameters\n"
        << "     using following modes, default mode is 'norm'\n"
        << "       short:   main comments only, no help or descr\n"
        << "                structs and arrays on a single line\n"
        << "       norm:    short + descriptions and help\n"
        << "       long:    norm  + arrays and structs expanded\n"
        << "       verbose: long  + private params included\n"
        << "       short_expand:   short with env vars expanded\n"
        << "       norm_expand:    norm with env vars expanded\n"
        << "       long_expand:    long with env vars expanded\n"
        << "       verbose_expand: verbose with env vars expanded\n"
        << "   [ -tdrp_debug] debugging prints for tdrp\n"
        << "   [ -tdrp_usage] print this usage\n";
  }

  ////////////////////////////////////////////
  // arrayRealloc()
  //
  // Realloc 1D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::arrayRealloc(const char *param_name, int new_array_n)
  {
    if (tdrpArrayRealloc(_table, &_start_,
                         param_name, new_array_n)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // array2DRealloc()
  //
  // Realloc 2D array.
  //
  // If size is increased, the values from the last array 
  // entry is copied into the new space.
  //
  // Returns 0 on success, -1 on error.
  //

  int Params::array2DRealloc(const char *param_name,
                             int new_array_n1,
                             int new_array_n2)
  {
    if (tdrpArray2DRealloc(_table, &_start_, param_name,
                           new_array_n1, new_array_n2)) {
      return (-1);
    } else {
      return (0);
    }
  }

  ////////////////////////////////////////////
  // _init()
  //
  // Class table initialization function.
  //
  //

  void Params::_init()

  {

    TDRPtable *tt = _table;

    // Parameter 'Comment 0'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 0");
    tt->comment_hdr = tdrpStrDup("Spline Analysis at Mesoscale Utilizing Radar and Aircraft Instrumentation.");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 1'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 1");
    tt->comment_hdr = tdrpStrDup("DEBUGGING SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug_bgu'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("debug_bgu");
    tt->descr = tdrpStrDup("Dump the content of the bgU array");
    tt->help = tdrpStrDup("If true, the bgU array will be dumped into a netcdf file");
    tt->val_offset = (char *) &debug_bgu - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'debug_bgu_nc'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("debug_bgu_nc");
    tt->descr = tdrpStrDup("Dump the content of the bgU array in this file");
    tt->help = tdrpStrDup("If debug_bgu is set to true, the bgU array will be dumped into this file");
    tt->val_offset = (char *) &debug_bgu_nc - &_start_;
    tt->single_val.s = tdrpStrDup("/tmp/bgu.nc");
    tt++;
    
    // Parameter 'debug_bgin'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("debug_bgin");
    tt->descr = tdrpStrDup("Dump the content of the bgIn array");
    tt->help = tdrpStrDup("If true, the bgIn array will be dumped on stdout");
    tt->val_offset = (char *) &debug_bgin - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'debug_bgu_overwrite'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("debug_bgu_overwrite");
    tt->descr = tdrpStrDup("Overwrite bgU with the content of this file");
    tt->help = tdrpStrDup("If set to a valid file, the bgU array will be overwritten");
    tt->val_offset = (char *) &debug_bgu_overwrite - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'debug_kd'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("debug_kd");
    tt->descr = tdrpStrDup("Debug the KD tree");
    tt->help = tdrpStrDup("If set to a non-zero value val, dump val/step KD tree lookup");
    tt->val_offset = (char *) &debug_kd - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'debug_kd_step'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("debug_kd_step");
    tt->descr = tdrpStrDup("Step for decrementing debug_kd");
    tt->help = tdrpStrDup("debug_kd is decremented by this value");
    tt->val_offset = (char *) &debug_kd_step - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'Comment 2'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 2");
    tt->comment_hdr = tdrpStrDup("BACKGROUND SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'load_background'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("load_background");
    tt->descr = tdrpStrDup("Tell Samurai to load background observations");
    tt->help = tdrpStrDup("TODO");
    tt->val_offset = (char *) &load_background - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'load_bg_coefficients'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("load_bg_coefficients");
    tt->descr = tdrpStrDup("Tell Samurai to load background coefficients");
    tt->help = tdrpStrDup("TODO");
    tt->val_offset = (char *) &load_bg_coefficients - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'adjust_background'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("adjust_background");
    tt->descr = tdrpStrDup("Tell Samurai to adjust the background observations");
    tt->help = tdrpStrDup("Adjust the interpolated background to satisfy mass continuity and match the supplied points exactly");
    tt->val_offset = (char *) &adjust_background - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'bkgd_obs_interpolation'
    // ctype is '_bkgd_interp_method_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("bkgd_obs_interpolation");
    tt->descr = tdrpStrDup("Interpolation method to fit background observations to the grid");
    tt->help = tdrpStrDup("TODO explain the various methods here");
    tt->val_offset = (char *) &bkgd_obs_interpolation - &_start_;
    tt->enum_def.name = tdrpStrDup("bkgd_interp_method_t");
    tt->enum_def.nfields = 4;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("INTERP_NONE");
      tt->enum_def.fields[0].val = INTERP_NONE;
      tt->enum_def.fields[1].name = tdrpStrDup("INTERP_SPLINE");
      tt->enum_def.fields[1].val = INTERP_SPLINE;
      tt->enum_def.fields[2].name = tdrpStrDup("INTERP_KD_TREE");
      tt->enum_def.fields[2].val = INTERP_KD_TREE;
      tt->enum_def.fields[3].name = tdrpStrDup("INTERP_FRACTL");
      tt->enum_def.fields[3].val = INTERP_FRACTL;
    tt->single_val.e = INTERP_SPLINE;
    tt++;
    
    // Parameter 'Comment 3'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 3");
    tt->comment_hdr = tdrpStrDup("OPERATION SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'mode'
    // ctype is '_mode_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("mode");
    tt->descr = tdrpStrDup("Coordinate system");
    tt->help = tdrpStrDup("XYZ for Cartesian, RTZ for spherical");
    tt->val_offset = (char *) &mode - &_start_;
    tt->enum_def.name = tdrpStrDup("mode_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("MODE_XYZ");
      tt->enum_def.fields[0].val = MODE_XYZ;
      tt->enum_def.fields[1].name = tdrpStrDup("MODE_RTZ");
      tt->enum_def.fields[1].val = MODE_RTZ;
    tt->single_val.e = MODE_XYZ;
    tt++;

    // Parameter 'analysis_type'
    // ctype is '_analysis_type_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("analysis_type");
    tt->descr = tdrpStrDup("Type of analysis to perform");
    tt->help = tdrpStrDup("TODO");
    tt->val_offset = (char *) &analysis_type - &_start_;
    tt->enum_def.name = tdrpStrDup("analysis_type_t");
    tt->enum_def.nfields = 3;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("WIND");
      tt->enum_def.fields[0].val = WIND;
      tt->enum_def.fields[1].name = tdrpStrDup("THERMO");
      tt->enum_def.fields[1].val = THERMO;
      tt->enum_def.fields[2].name = tdrpStrDup("WIND_THERMO");
      tt->enum_def.fields[2].val = WIND_THERMO;
    tt->single_val.e = WIND;
    tt++;

    
    // Parameter 'projection'
    // ctype is '_projection_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = ENUM_TYPE;
    tt->param_name = tdrpStrDup("projection");
    tt->descr = tdrpStrDup("Projection");
    tt->help = tdrpStrDup("TODO");
    tt->val_offset = (char *) &projection - &_start_;
    tt->enum_def.name = tdrpStrDup("projection_t");
    tt->enum_def.nfields = 2;
    tt->enum_def.fields = (enum_field_t *)
        tdrpMalloc(tt->enum_def.nfields * sizeof(enum_field_t));
      tt->enum_def.fields[0].name = tdrpStrDup("PROJ_LAMBERT_CONFORMAL_CONIC");
      tt->enum_def.fields[0].val = PROJ_LAMBERT_CONFORMAL_CONIC;
      tt->enum_def.fields[1].name = tdrpStrDup("PROJ_TRANSVERSE_MERCATOR_EXACT");
      tt->enum_def.fields[1].val = PROJ_TRANSVERSE_MERCATOR_EXACT;
    tt->single_val.e = PROJ_TRANSVERSE_MERCATOR_EXACT;
    tt++;
    
    // Parameter 'data_directory'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("data_directory");
    tt->descr = tdrpStrDup("Path to the data directory");
    tt->help = tdrpStrDup("Samurai will load data files from this directory");
    tt->val_offset = (char *) &data_directory - &_start_;
    tt->single_val.s = tdrpStrDup("not_set");
    tt++;
    
    // Parameter 'output_directory'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("output_directory");
    tt->descr = tdrpStrDup("Path to the output directory");
    tt->help = tdrpStrDup("Samurai will write result files in this directory");
    tt->val_offset = (char *) &output_directory - &_start_;
    tt->single_val.s = tdrpStrDup("not_set");
    tt++;
    
    // Parameter 'preprocess_obs'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("preprocess_obs");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("TODO");
    tt->val_offset = (char *) &preprocess_obs - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'num_iterations'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("num_iterations");
    tt->descr = tdrpStrDup("Max number of iterations to the multipass reduction factor");
    tt->help = tdrpStrDup("Multiple iterations will reduce the cutoff wavelengths and background error variance");
    tt->val_offset = (char *) &num_iterations - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'output_mish'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_mish");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_mish - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_txt'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_txt");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_txt - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_qc'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_qc");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_qc - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'output_netcdf'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_netcdf");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_netcdf - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'output_asi'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_asi");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_asi - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'output_COAMPS'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("output_COAMPS");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_COAMPS - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'save_mish'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("save_mish");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &save_mish - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 4'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 4");
    tt->comment_hdr = tdrpStrDup("GRID DEFINITION SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'i_min'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("i_min");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_min - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'i_max'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("i_max");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_max - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'i_incr'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("i_incr");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_incr - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'j_min'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("j_min");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_min - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'j_max'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("j_max");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_max - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'j_incr'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("j_incr");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_incr - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'k_min'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("k_min");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_min - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'k_max'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("k_max");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_max - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'k_incr'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("k_incr");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_incr - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'Comment 5'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 5");
    tt->comment_hdr = tdrpStrDup("BACKGROUND SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'ref_state'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ref_state");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ref_state - &_start_;
    tt->single_val.s = tdrpStrDup("dunion_mt.snd");
    tt++;
    
    // Parameter 'ref_time'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("ref_time");
    tt->descr = tdrpStrDup("Reference time");
    tt->help = tdrpStrDup("hh:mm:ss");
    tt->val_offset = (char *) &ref_time - &_start_;
    tt->single_val.s = tdrpStrDup("not_set");
    tt++;
    
    // Parameter 'i_background_roi'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("i_background_roi");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Radius of influence in the I direction");
    tt->val_offset = (char *) &i_background_roi - &_start_;
    tt->single_val.f = 20;
    tt++;
    
    // Parameter 'j_background_roi'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("j_background_roi");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Radius of influence in the J direction");
    tt->val_offset = (char *) &j_background_roi - &_start_;
    tt->single_val.f = 20;
    tt++;
    
    // Parameter 'Comment 6'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 6");
    tt->comment_hdr = tdrpStrDup("RADAR SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'radar_skip'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("radar_skip");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &radar_skip - &_start_;
    tt->single_val.i = 2;
    tt++;
    
    // Parameter 'radar_stride'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("radar_stride");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &radar_stride - &_start_;
    tt->single_val.i = 3;
    tt++;
    
    // Parameter 'dynamic_stride'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("dynamic_stride");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &dynamic_stride - &_start_;
    tt->single_val.i = 0;
    tt++;
    
    // Parameter 'qr_variable'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("qr_variable");
    tt->descr = tdrpStrDup("???");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &qr_variable - &_start_;
    tt->single_val.s = tdrpStrDup("dbz");
    tt++;
    
    // Parameter 'radar_dbz'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("radar_dbz");
    tt->descr = tdrpStrDup("Radar reflectivity variable name in the input files");
    tt->help = tdrpStrDup("Example: DBZ for Eldora, DZ for CSU-CHILL");
    tt->val_offset = (char *) &radar_dbz - &_start_;
    tt->single_val.s = tdrpStrDup("DBZ");
    tt++;
    
    // Parameter 'radar_vel'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("radar_vel");
    tt->descr = tdrpStrDup("Radar velocity of scatterers away from instrument");
    tt->help = tdrpStrDup("Example: VG for Eldora, VE for CSU-CHILL, VR, ...");
    tt->val_offset = (char *) &radar_vel - &_start_;
    tt->single_val.s = tdrpStrDup("VG");
    tt++;
    
    // Parameter 'radar_sw'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("radar_sw");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &radar_sw - &_start_;
    tt->single_val.s = tdrpStrDup("SW");
    tt++;
    
    // Parameter 'i_reflectivity_roi'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("i_reflectivity_roi");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_reflectivity_roi - &_start_;
    tt->single_val.f = 0.4;
    tt++;
    
    // Parameter 'j_reflectivity_roi'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("j_reflectivity_roi");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_reflectivity_roi - &_start_;
    tt->single_val.f = 0.4;
    tt++;
    
    // Parameter 'k_reflectivity_roi'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("k_reflectivity_roi");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_reflectivity_roi - &_start_;
    tt->single_val.f = 0.4;
    tt++;
    
    // Parameter 'dbz_pseudow_weight'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("dbz_pseudow_weight");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &dbz_pseudow_weight - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'mask_reflectivity'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("mask_reflectivity");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mask_reflectivity - &_start_;
    tt->single_val.f = -26;
    tt++;
    
    // Parameter 'melting_zone_width'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("melting_zone_width");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &melting_zone_width - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'mixed_phase_dbz'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("mixed_phase_dbz");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mixed_phase_dbz - &_start_;
    tt->single_val.f = 20;
    tt++;
    
    // Parameter 'rain_dbz'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("rain_dbz");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &rain_dbz - &_start_;
    tt->single_val.f = 30;
    tt++;
    
    // Parameter 'Comment 7'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 7");
    tt->comment_hdr = tdrpStrDup("PARAMETERS SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'Comment 8'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 8");
    tt->comment_hdr = tdrpStrDup("BOUNDARY CONDITIONS SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'i_rhou_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_rhou_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_rhou_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_rhou_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_rhou_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_rhou_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_rhov_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_rhov_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_rhov_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_rhov_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_rhov_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_rhov_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_rhow_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_rhow_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_rhow_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_rhow_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_rhow_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_rhow_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_tempk_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_tempk_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_tempk_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_tempk_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_tempk_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_tempk_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_qv_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_qv_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_qv_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_qv_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_qv_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_qv_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_rhoa_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_rhoa_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_rhoa_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_rhoa_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_rhoa_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_rhoa_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_qr_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_qr_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_qr_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'i_qr_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("i_qr_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &i_qr_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_rhou_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_rhou_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_rhou_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_rhou_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_rhou_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_rhou_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_rhov_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_rhov_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_rhov_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_rhov_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_rhov_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_rhov_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_rhow_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_rhow_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_rhow_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_rhow_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_rhow_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_rhow_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_tempk_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_tempk_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_tempk_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_tempk_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_tempk_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_tempk_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_qv_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_qv_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_qv_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_qv_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_qv_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_qv_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_rhoa_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_rhoa_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_rhoa_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_rhoa_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_rhoa_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_rhoa_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_qr_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_qr_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_qr_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'j_qr_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("j_qr_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &j_qr_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_rhou_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_rhou_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_rhou_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_rhou_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_rhou_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_rhou_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_rhov_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_rhov_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_rhov_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_rhov_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_rhov_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_rhov_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_rhow_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_rhow_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_rhow_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_rhow_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_rhow_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_rhow_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_tempk_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_tempk_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_tempk_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_tempk_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_tempk_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_tempk_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_qv_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_qv_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_qv_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_qv_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_qv_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_qv_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_rhoa_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_rhoa_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_rhoa_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_rhoa_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_rhoa_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_rhoa_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_qr_bcL'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_qr_bcL");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_qr_bcL - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'k_qr_bcR'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("k_qr_bcR");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &k_qr_bcR - &_start_;
    tt->single_val.s = tdrpStrDup("R0");
    tt++;
    
    // Parameter 'Comment 9'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 9");
    tt->comment_hdr = tdrpStrDup("OBSERVATION ERRORS SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'dropsonde_rhoa_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("dropsonde_rhoa_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &dropsonde_rhoa_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'dropsonde_rhou_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("dropsonde_rhou_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &dropsonde_rhou_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'dropsonde_rhov_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("dropsonde_rhov_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &dropsonde_rhov_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'dropsonde_rhow_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("dropsonde_rhow_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &dropsonde_rhow_error - &_start_;
    tt->single_val.f = 2;
    tt++;
    
    // Parameter 'dropsonde_tempk_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("dropsonde_tempk_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &dropsonde_tempk_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'dropsonde_qv_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("dropsonde_qv_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &dropsonde_qv_error - &_start_;
    tt->single_val.f = 0.5;
    tt++;
    
    // Parameter 'dropsonde_rhoua_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("dropsonde_rhoua_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &dropsonde_rhoua_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'flightlevel_rhoa_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("flightlevel_rhoa_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &flightlevel_rhoa_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'flightlevel_rhou_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("flightlevel_rhou_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &flightlevel_rhou_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'flightlevel_rhov_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("flightlevel_rhov_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &flightlevel_rhov_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'flightlevel_rhow_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("flightlevel_rhow_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &flightlevel_rhow_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'flightlevel_tempk_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("flightlevel_tempk_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &flightlevel_tempk_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'flightlevel_qv_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("flightlevel_qv_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &flightlevel_qv_error - &_start_;
    tt->single_val.f = 0.5;
    tt++;
    
    // Parameter 'flightlevel_rhoua_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("flightlevel_rhoua_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &flightlevel_rhoua_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'mtp_rhoa_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("mtp_rhoa_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mtp_rhoa_error - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'mtp_tempk_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("mtp_tempk_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mtp_tempk_error - &_start_;
    tt->single_val.f = 0;
    tt++;
    
    // Parameter 'insitu_rhoa_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("insitu_rhoa_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &insitu_rhoa_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'insitu_rhou_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("insitu_rhou_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &insitu_rhou_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'insitu_rhov_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("insitu_rhov_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &insitu_rhov_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'insitu_rhow_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("insitu_rhow_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &insitu_rhow_error - &_start_;
    tt->single_val.f = 2;
    tt++;
    
    // Parameter 'insitu_tempk_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("insitu_tempk_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &insitu_tempk_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'insitu_qv_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("insitu_qv_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &insitu_qv_error - &_start_;
    tt->single_val.f = 0.5;
    tt++;
    
    // Parameter 'insitu_rhoua_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("insitu_rhoua_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &insitu_rhoua_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'sfmr_windspeed_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("sfmr_windspeed_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &sfmr_windspeed_error - &_start_;
    tt->single_val.f = 10;
    tt++;
    
    // Parameter 'qscat_rhou_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("qscat_rhou_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &qscat_rhou_error - &_start_;
    tt->single_val.f = 2.5;
    tt++;
    
    // Parameter 'qscat_rhov_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("qscat_rhov_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &qscat_rhov_error - &_start_;
    tt->single_val.f = 2.5;
    tt++;
    
    // Parameter 'ascat_rhou_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("ascat_rhou_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ascat_rhou_error - &_start_;
    tt->single_val.f = 2.5;
    tt++;
    
    // Parameter 'ascat_rhov_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("ascat_rhov_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &ascat_rhov_error - &_start_;
    tt->single_val.f = 2.5;
    tt++;
    
    // Parameter 'amv_rhou_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("amv_rhou_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &amv_rhou_error - &_start_;
    tt->single_val.f = 10;
    tt++;
    
    // Parameter 'amv_rhov_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("amv_rhov_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &amv_rhov_error - &_start_;
    tt->single_val.f = 10;
    tt++;
    
    // Parameter 'lidar_sw_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("lidar_sw_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &lidar_sw_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'lidar_power_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("lidar_power_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &lidar_power_error - &_start_;
    tt->single_val.f = 50;
    tt++;
    
    // Parameter 'lidar_min_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("lidar_min_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &lidar_min_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'radar_sw_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("radar_sw_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &radar_sw_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'radar_fallspeed_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("radar_fallspeed_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &radar_fallspeed_error - &_start_;
    tt->single_val.f = 2;
    tt++;
    
    // Parameter 'radar_min_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("radar_min_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &radar_min_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'aeri_qv_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("aeri_qv_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &aeri_qv_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'aeri_rhoa_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("aeri_rhoa_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &aeri_rhoa_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'aeri_rhou_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("aeri_rhou_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &aeri_rhou_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'aeri_rhov_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("aeri_rhov_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &aeri_rhov_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'aeri_rhow_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("aeri_rhow_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &aeri_rhow_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'aeri_tempk_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("aeri_tempk_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &aeri_tempk_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'bg_obs_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("bg_obs_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &bg_obs_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'bg_interpolation_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("bg_interpolation_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &bg_interpolation_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'mesonet_qv_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("mesonet_qv_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mesonet_qv_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'mesonet_rhoa_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("mesonet_rhoa_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mesonet_rhoa_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'mesonet_rhou_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("mesonet_rhou_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mesonet_rhou_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'mesonet_rhov_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("mesonet_rhov_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mesonet_rhov_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'mesonet_rhow_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("mesonet_rhow_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mesonet_rhow_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'mesonet_tempk_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("mesonet_tempk_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &mesonet_tempk_error - &_start_;
    tt->single_val.f = 1;
    tt++;
    
    // Parameter 'Comment 10'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 10");
    tt->comment_hdr = tdrpStrDup("XYP SPECIFIC SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'output_latlon_increment'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("output_latlon_increment");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_latlon_increment - &_start_;
    tt->single_val.f = -1;
    tt++;
    
    // Parameter 'output_pressure_increment'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("output_pressure_increment");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &output_pressure_increment - &_start_;
    tt->single_val.f = -1;
    tt++;
    
    // Parameter 'Comment 11'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 11");
    tt->comment_hdr = tdrpStrDup("OPTION SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'max_radar_elevation'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("max_radar_elevation");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &max_radar_elevation - &_start_;
    tt->single_val.f = 45;
    tt++;
    
    // Parameter 'horizontal_radar_appx'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("horizontal_radar_appx");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &horizontal_radar_appx - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'allow_background_missing_values'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("allow_background_missing_values");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &allow_background_missing_values - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'allow_negative_angles'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("allow_negative_angles");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &allow_negative_angles - &_start_;
    tt->single_val.b = pTRUE;
    tt++;
    
    // Parameter 'array_order'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("array_order");
    tt->descr = tdrpStrDup("Order of compressed arrays passed through samurai.h interface");
    tt->help = tdrpStrDup("One of row_order or column_order");
    tt->val_offset = (char *) &array_order - &_start_;
    tt->single_val.s = tdrpStrDup("row_order");
    tt++;
    
    // Parameter 'bg_interpolation'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("bg_interpolation");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->val_offset = (char *) &bg_interpolation - &_start_;
    tt->single_val.s = tdrpStrDup("none");
    tt++;
    
    // Parameter 'Comment 12'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 12");
    tt->comment_hdr = tdrpStrDup("KD TREE NEAREST NEIGHBOR SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'bkgd_kd_max_distance'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("bkgd_kd_max_distance");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Any point outside of that distance will be ignored");
    tt->val_offset = (char *) &bkgd_kd_max_distance - &_start_;
    tt->single_val.f = 20;
    tt++;
    
    // Parameter 'bkgd_kd_num_neighbors'
    // ctype is 'int'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = INT_TYPE;
    tt->param_name = tdrpStrDup("bkgd_kd_num_neighbors");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Values will be averaged over these many nearest neighbors");
    tt->val_offset = (char *) &bkgd_kd_num_neighbors - &_start_;
    tt->single_val.i = 1;
    tt++;
    
    // Parameter 'Comment 13'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 13");
    tt->comment_hdr = tdrpStrDup("FRACTL INTERFACE SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'fractl_nc_file'
    // ctype is 'char*'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = STRING_TYPE;
    tt->param_name = tdrpStrDup("fractl_nc_file");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Need bkgd_obs_interpolation set to INTERP_FRACTL to be used");
    tt->val_offset = (char *) &fractl_nc_file - &_start_;
    tt->single_val.s = tdrpStrDup("");
    tt++;
    
    // Parameter 'use_fractl_errors'
    // ctype is 'tdrp_bool_t'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = BOOL_TYPE;
    tt->param_name = tdrpStrDup("use_fractl_errors");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("Need bkgd_obs_interpolation set to 'fractl' to be used");
    tt->val_offset = (char *) &use_fractl_errors - &_start_;
    tt->single_val.b = pFALSE;
    tt++;
    
    // Parameter 'Comment 14'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = COMMENT_TYPE;
    tt->param_name = tdrpStrDup("Comment 14");
    tt->comment_hdr = tdrpStrDup("ITERATION DEPENDENT SECTION");
    tt->comment_text = tdrpStrDup("");
    tt++;
    
    // Parameter 'mc_weight'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("mc_weight");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_mc_weight - &_start_;
    tt->array_n_offset = (char *) &mc_weight_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 1;
      tt->array_vals[1].f = 1;
    tt++;
    
    // Parameter 'neumann_u_weight'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("neumann_u_weight");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_neumann_u_weight - &_start_;
    tt->array_n_offset = (char *) &neumann_u_weight_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 0.01;
      tt->array_vals[1].f = 0.01;
    tt++;
    
    // Parameter 'neumann_v_weight'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("neumann_v_weight");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_neumann_v_weight - &_start_;
    tt->array_n_offset = (char *) &neumann_v_weight_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 0.01;
      tt->array_vals[1].f = 0.01;
    tt++;
    
    // Parameter 'dirichlet_w_weight'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("dirichlet_w_weight");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_dirichlet_w_weight - &_start_;
    tt->array_n_offset = (char *) &dirichlet_w_weight_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 0.01;
      tt->array_vals[1].f = 0.01;
    tt++;
    
    // Parameter 'bg_qr_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("bg_qr_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_bg_qr_error - &_start_;
    tt->array_n_offset = (char *) &bg_qr_error_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 3;
      tt->array_vals[1].f = 1;
    tt++;
    
    // Parameter 'bg_qv_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("bg_qv_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_bg_qv_error - &_start_;
    tt->array_n_offset = (char *) &bg_qv_error_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 3;
      tt->array_vals[1].f = 1;
    tt++;
    
    // Parameter 'bg_rhoa_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("bg_rhoa_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_bg_rhoa_error - &_start_;
    tt->array_n_offset = (char *) &bg_rhoa_error_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 3;
      tt->array_vals[1].f = 1;
    tt++;
    
    // Parameter 'bg_rhou_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("bg_rhou_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_bg_rhou_error - &_start_;
    tt->array_n_offset = (char *) &bg_rhou_error_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 100;
      tt->array_vals[1].f = 5;
    tt++;
    
    // Parameter 'bg_rhov_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("bg_rhov_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_bg_rhov_error - &_start_;
    tt->array_n_offset = (char *) &bg_rhov_error_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 100;
      tt->array_vals[1].f = 5;
    tt++;
    
    // Parameter 'bg_rhow_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("bg_rhow_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_bg_rhow_error - &_start_;
    tt->array_n_offset = (char *) &bg_rhow_error_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 100;
      tt->array_vals[1].f = 5;
    tt++;
    
    // Parameter 'bg_tempk_error'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("bg_tempk_error");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_bg_tempk_error - &_start_;
    tt->array_n_offset = (char *) &bg_tempk_error_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 3;
      tt->array_vals[1].f = 1;
    tt++;
    
    // Parameter 'i_filter_length'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("i_filter_length");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_i_filter_length - &_start_;
    tt->array_n_offset = (char *) &i_filter_length_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 4;
      tt->array_vals[1].f = 2;
    tt++;
    
    // Parameter 'j_filter_length'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("j_filter_length");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_j_filter_length - &_start_;
    tt->array_n_offset = (char *) &j_filter_length_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 4;
      tt->array_vals[1].f = 2;
    tt++;
    
    // Parameter 'k_filter_length'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("k_filter_length");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_k_filter_length - &_start_;
    tt->array_n_offset = (char *) &k_filter_length_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 4;
      tt->array_vals[1].f = 2;
    tt++;
    
    // Parameter 'i_spline_cutoff'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("i_spline_cutoff");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_i_spline_cutoff - &_start_;
    tt->array_n_offset = (char *) &i_spline_cutoff_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 2;
      tt->array_vals[1].f = 2;
    tt++;
    
    // Parameter 'j_spline_cutoff'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("j_spline_cutoff");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_j_spline_cutoff - &_start_;
    tt->array_n_offset = (char *) &j_spline_cutoff_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 2;
      tt->array_vals[1].f = 2;
    tt++;
    
    // Parameter 'k_spline_cutoff'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("k_spline_cutoff");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_k_spline_cutoff - &_start_;
    tt->array_n_offset = (char *) &k_spline_cutoff_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = 2;
      tt->array_vals[1].f = 2;
    tt++;
    
    // Parameter 'i_max_wavenumber'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("i_max_wavenumber");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_i_max_wavenumber - &_start_;
    tt->array_n_offset = (char *) &i_max_wavenumber_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = -1;
      tt->array_vals[1].f = -1;
    tt++;
    
    // Parameter 'j_max_wavenumber'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("j_max_wavenumber");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_j_max_wavenumber - &_start_;
    tt->array_n_offset = (char *) &j_max_wavenumber_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = -1;
      tt->array_vals[1].f = -1;
    tt++;
    
    // Parameter 'k_max_wavenumber'
    // ctype is 'float'
    
    memset(tt, 0, sizeof(TDRPtable));
    tt->ptype = FLOAT_TYPE;
    tt->param_name = tdrpStrDup("k_max_wavenumber");
    tt->descr = tdrpStrDup("");
    tt->help = tdrpStrDup("");
    tt->array_offset = (char *) &_k_max_wavenumber - &_start_;
    tt->array_n_offset = (char *) &k_max_wavenumber_n - &_start_;
    tt->is_array = TRUE;
    tt->array_len_fixed = FALSE;
    tt->array_elem_size = sizeof(float);
    tt->array_n = 2;
    tt->array_vals = (tdrpVal_t *)
        tdrpMalloc(tt->array_n * sizeof(tdrpVal_t));
      tt->array_vals[0].f = -1;
      tt->array_vals[1].f = -1;
    tt++;
    
    // trailing entry has param_name set to NULL
    
    tt->param_name = NULL;
    
    return;
  
  }
